# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    notes.org                                          :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: archid- <archid-@student.1337.ma>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2019/11/17 16:37:08 by archid-           #+#    #+#              #
#    Updated: 2019/11/17 16:39:26 by archid-          ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

#+TITLE: Intoduction to algorithms, Devide and Conquer

* Example of finding whether a relative array is sorted or not

		  NOTE: A is sorted in accesnding order, looking for 6

		   A is not rotated, B is rotated by 4 steps. Both have distinct
		   integers (possibly negative too). thus, mid is preserved with
		   index, otherwise, we shall think of duplicates as one chunk.
		   by changing the high and low correspodenly.

		   - mid of A is 8, where A[8] = 8.
		   - mid of B is 3, where B[8] = 3 but the relative mid of A is
		     at index [13]

		   now, notes about the rotation and the mid since the rotation,
		   i guess we can know which side to go to based on the last one.

		   we look for e, where e == 6,

		   A: 0  1  2  3  4  5 6 7 8 9 10 11 12 13 14 15 16 17


		   // reverse rotation (rr) right/down
		   B: 13 14 15 16 17 0 1 2 3 4 5  6  7  8  9  10 11 12
		                           ^            ^

								  mid      relative mid

		   ------------------------v-----------------------
		   // normal rotation (r)
		   C: 5  6  7  8  9 10 11 12 13 14 15 16 17 0 1 2 3 4
		   left/up
		               ^
				  relative mid

		   // Part II

		   steps of the process
		   ~~~~~~~~~~~~~~~~~~~~~~~

		   #0 - calling binary_search_rot, we find out that low is bigger than
		   high, thus it was a right side rotation. the sorted part is the one
		   on the left, while right side is not. this is caused by the shift of
		   mid to right side. we shall see which side of the two the search key
		   is in. if found on the left. we shall check in which side it falls.

		   if it's between B[low] and B[mid], then do a plain binary search
		   since we already know that the left region is sorted (B[low] and
		   B[mid]).

		   A[i]  \  i   | shift | low | mid | high|
		   -------------+-------+-----+-----+-----+
		     B          | right | 13  | 3   |  12 |
			 C          | left  | 5   | 12  |  4  |


		   // Part I

		   this is a right side rotation, meaning that the left range is
		   unsorted. we shall focus on the right range. so that right,
		   right seems in place. (i guess that left rotation is the same case)

		   now to actually find the mid, we shall find which side is the
		   one sorted.

		   now the mid of b will lead to which side to take, so after we shall
		   find the range of operation. first, see if low < mid, if so then pick
		   and we know that the order is ascending, thus: the missed part is
		   the on the right, we shall take the left side.

		   binary_search_rot:

		   given:

				a search key element, e.
				three indices low, mid and high.

		   if (MAX(e, B[low]) == B[low]) && (MIN(e, B[mid]) == B[mid])
				high = mid
				call binary_search(b, low, mid)
		   else
		       low = mid + 1
			   recall binary_search_rot(b, mid, high)

		   the example abive is in case of a rotation
		   while on the right it will change the side of working

		   if (MAX(e, B[mid]) == e && MIN(e, B[high]) == e)


		   -------------
		   #1

		   e == 6
		   B[low] == 13 and B[high] == 12, thus array is rotated to the right
		   B[]
