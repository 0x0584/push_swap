* Writing README doesn't matter anymore

When correction time will come, only truth will remain! I shall finish this soon. I'm working like I never did before. Part of it because I'm mad, and the other part is that I still got a story to tell!

Correction would be on: <2019-11-10 Sun 16:00> or maybe earlier, depends on technical details!

** What's left [6/12]

+return everything to stack A: sort the remainder elements (for the moment just two to use swap) and keep return elements from the mid as sorted ones based on their turns.+


+ [X] disordered pair :: 2 1 *PASS* 1 instruction =sa=
+ [X] ordered pair :: 1 2 *PASS* 0 instruction
+ [X] ordered sequence :: 1 2 3 4 *PASS* 0 instructions
+ [X] reversed sequence :: 4 3 2 1 *PASS* 8 instructions =ra ra pb pb rb sa pa pa=
+ [X] random  #1 :: 1 5 2 4 3 *PASS* 11 instructions =pb ra pb pb pb rb pa rrb pa pa pa=
+ [X] random #2 :: 2 1 3 6 5 8 *PASS* 11 instructions =pb pb rb pb ra pb sa pa pa pa pa=
+ [ ] random #3 :: 1 25 4 8 3 5 *FAILED* 13 instructions =pb ra pb ra pb rb pb sa pa pa rrb pa pa= /possible optimization is to synchronize the rotation/
+ [ ] random #4 :: 5 2 8 3 4 9 *FAILED* 13 instructions =pb pb rb ra pb rb pb sa pa pa rrb pa pa= /quick fix: rb & ra == rr/
+ [ ] few reversed :: 2 1 0 *FAILED* 6 instructions =ra pb pb rb pa pa= /maybe for fewer elements (like 2 or 3 elements) we can brute-force that/
+ [ ] inversed first :: 3 2 4 5 6 7 8 *FAILED* 15 instructions =pb pb rb pb pb pb rb pb pa rrb pa pa pa pa pa=
+ [ ] last inversed :: 2 3 4 5 6 8 7 *FAILED* 17 instructions =pb pb rb pb pb pb rb ra pb pa rrb pa pa pa rrb pa pa= /quick fix: rb & ra == rr and also synchronizing the rotation might help/
+ [ ] larger input :: input.txt *FAILED* nothing is sorted eventually

#+begin_quote
*UNDEFINED BEHAVIOR*

it seems like nothing is working! the trick of splitting works fine with smaller input, but it's not working with a larger input. probably because I do not put stuff into their place. Onion splitting is working fine, I might just rotation stack A to put the items in place. One idea that comes to mind is to get use a sorted version to track the order and then rotate based on that order.
#+end_quote

/Explanation:/ this is was because in terms of turn, I shall start picking nodes from biggest to the lowest, and /RANGE_MID/ before /RANGE_LOW/. This should not affect the previous tests, hopefully.

<2019-11-06 Wed 01:10> it is working! but, I got much more instructions than expected:

+ for 100_random_input I got 650 instructions, which is quite acceptable
+ for 500_random_input I got a fucking unacceptably 11007 instructions

/Possible Solution?/ Well, I shall not use onion splitting, since it requires always two operations to push a value that's a /RANGE_LOW/ to the bottom of stack B (ie. =pb rb=). A good idea is to only split into two parts so that each /turn/, we push the current /RANGE_LOW/. In this approach, we will only use one instruction, =pb= to push lower values, and we will guarantee that: $\forall e_1 \in turn_n, \forall e_2 \in turn_{n-1}; e_1 > e_2$.
