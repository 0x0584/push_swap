* About

Sorting one stack using another, with limited operation and done using the least number of instructions

* Algorithm

Some notes before reading the algorithm

+ /A stack is a sub stack of its self/
+ /Push send the element to the end of the stack/

This algorithm uses a tweaked quick-sort, where we divide the *stack A* into range classes, *sub stack*, based on the /mid/ value of each class.

_Details of the Algorithm_

1. find the /mid/ value of the whole array
2. use that /mid/ value to split *stack A* into half, where all values    /less than mid/ form a *sub stack* which we *push to stack B*
3. update the /mid/ value and repeat 2 until /no elements are left/ or /only two are left/
4. apply the same process backwards on each *sub stack*, since they're already sorted based on range, push elements back to *stack A*, only now we push the value /above the mid/ value


* Improved version
** notes

we must have an operator =t_list *get_element(t_stack, int)= which does the following

- find where is the element
- if above the half of =stack_src=, push enough =ra='s to get it on top
- else if below half of =stack_src=, push enough =rra='s

** example
A: [6 3 5 2 4 1] B: []
size: 6

after sorting the input we shall have A: [1 2 3 4 5 6]
divide the stack A into three same size sub stacks: 3x2 stacks [1 2] [3 4] [5 6]
find mid of range_0 which means either 6 or 5


* TODOs [1/1]

+ [X] Document on Quick Sort and Selection Sort
+ [ ] Implement the Algorithm
