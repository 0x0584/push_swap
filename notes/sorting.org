* About

Those are notes taken from [[https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/][OpenDSA Data Structures and Algorithms Modules Collection]]. The code source is distributed under [[https://opendsa-server.cs.vt.edu/ODSA/lib/license.html][OpenDSA License]].

* Sorting in general

Sorting is one of the most /frequently performed computing tasks/ e.g., We might sort the records so that we can search the collection efficiently as well as helping an algorithm to solve some other problem[fn:1].  Studying sorting algorithms helps us to /understand issues in algorithm design and analysis/.

**  devide and conquer

splitting the problem into smaller problems, but the devision task is specified differently among many algorithms

- Merge Sort :: Devide the list into halfs
- Quick Sort :: Devide the list into big/small values

** Time complexity

This evolves a wide variety of algorithm analysis techniques.  /Quicksort/ illustrates that it is possible for an algorithm to have an average case whose growth rate is significantly smaller than its worst case.  It is possible to speed up one sorting algorithm (such as /Shellsort/ or /Quicksort/) by taking advantage of the best case behavior of another algorithm, /Insertion Sort/.  Special case behavior by some sorting algorithms makes them a good solution for special niche applications, /Heapsort/.

# Terminology:
#
# stable sort algorithm :: preserve the relative order of duplicated key values.

* The $O(n^2)$ Approach

* The $O(n log_2 n)$ Approach

* The $O(n)$ Approach

* Footnotes

[fn:1] For example, Kruskal's algorithm to find a minimal-cost spanning tree must sort the edges of a graph by their lengths before it can process them.
